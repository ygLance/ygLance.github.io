---
title: 线性同余方程
date: 2020-04-01 15:59:30
categories:
- 算法
tags:
- 基础
- 数学
excerpt_separator: <!--more-->
---

# 线性同余方程

------

## 辗转相除法

求gcd的基本方法是辗转相除法,即欧几里得算法

用较大数除以较小数，再用出现的余数（第一余数）去除除数，再用出现的余数（第二余数）去除第一余数，如此反复，直到最后余数是0为止。如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数。
<!--more-->
```cpp
int gcd(int a,int b){
	if(a>b){
		a=a+b;b=a-b;a=a-b;
    }
    int tmp1= a,tmp2= b;
    while(tmp1){
		int tmpp=tmp1;
        tmp1=tmp2%tmp1;
        tmp2=tmpp;
    }
    int gcd=tmp2;
    return gcd;
}
```

```cpp
//有一个简洁的代码,这个可读性还更高.....
//a>b
int gcd(int a,int b){
    int a%b=tmp;
	return tmp ? gcd(b,tmp):b;
}
```

```cpp
gcd()//当然,你可以用stl
```

------

## 贝祖定理

若a,b为整数,则必有$ax+by=gcd(a,b)$

即,若$ax+by=m$有解,m是gcd的倍数

-----

## 求解线性同余方程

在我们求解$ax+by=m$时,显然只需要求出$ax+by=gcd(a,b)$的一组解,欧几里得算法不返回x,y的值,所以使用扩展欧几里得算法求出一组特解

### 扩展欧几里得算法

对于辗转相除法的其中任两步有(存在):

$$\begin{cases}ax_1+by_2=gcd(a,b)\\ bx_2+(a\quad mod\quad b)y_2 = gcd(b,a\quad  mod\quad b) \end{cases}$$

其中$a\quad mod\quad b$即为$a-[a/b]*b$ ,故由欧几里得原理得到

$gcd(a,b) = gcd(b,a\quad mod \quad b)$

即:  $ax_1+by_1=bx_2+(a-[a/b]*b)y_2$

即:  $ax_1+by_1= ay_2+bx_2-[a/b]*by_2$

由恒等原理:

$$\begin{cases}x_1=y_2\\ y_1=x_2-[a/b]*y_2\end{cases}$$

用递推,显然我们可以得到$x_1,y_1$的值

在欧几里得算法中,由我们在最后一步中使用的那个除式$m/n=t$即 $m \% n=0$

(n即为gcd)我们得到$mx+ny=n$这个方程~~,枚举求此不定方程的解,每一组解通过上面的递推式可得原方程....~~

我呸! 脑子有问题,显然有一组解$\begin{cases}x=0\\y=1\end{cases}$,你要去枚举不等于没求嘛,直接枚举原来的不一样吗.这样我们就求出了一组特解,通过此特解,显然$\begin{cases}x=x_0+bt\\ y=y_0-at\end{cases}$即为全部解(有无数个的)

### 扩欧的实现

```cpp
//先给出这个版本...
int exgcd(int a,int b,int &x,int &y)
{
    if(b==0)
    {
        x=1;y=0;
        return a;  //到达递归边界开始向上一层返回
    }
    int r=exgcd(b,a%b,x,y);
    int temp=y;    //把x y变成上一层的
    y=x-(a/b)*y;
    x=temp;
    return r;     //gcd
}
```

这段代码的含义,首先,用欧几里得算法求出gcd,然后一层层的往回退,第一层是那组特解0和1,来时,一层进行一次ab到ab的映射,回时,一层进行一次xy到xy的映射(我们上面求出来了!)最终xy与调用他的那个ab匹配(显然的,0和1就是匹配最后那组的)这样,回到最外层的流中,执行完求r后,xy和b,a%b匹配(dp的样子),完成最后几句,xy的值与形参ab匹配,函数结束.得到了gcd和一组特解xy.