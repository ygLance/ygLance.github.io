---
title: 序列自动机
date: 2020-4-2 01:31:30
description : 
categories:
- 字符串
tags:
- 子序列
- 自动机
excerpt_separator: <!--more-->
---
# 序列自动机
通过一个预处理,
对子序列实现$O(n)$的查询

注意,使用getchar()时必须清空缓冲
<!--more-->
------

## 预处理

开一个数组$next[len][26]$

从后往前扫一遍,数组记录从这点开始,下一个此种字符出现的位置:

(最后一个数据默认是0,0,0,0....这个next数组编号从1其,0位存放每个字母出现的第一个位置)

```cpp
    for(int i=n; i>0; i--)
    {
    	for(int j=0; j<=25; j++) nex[i-1][j] = nex[i][j]; 
    	nex[i-1][s[i]-'a'] = i;
    }
```

## 简单查询

初始位置设置为0,开始逐个查询子串中的每一个字符,(注意是子串不是连续子串)

显然,如果$next[i][ch]$为0(这个0是一开始的初始值),即后面再也没有这个字符了,即匹配失败,否则,更新下一次查询位置为这个值,查询下一个字符的位置.

```cpp
while(n--)
	{
		int f = 0,p=0;//p为位置
		while((c = getchar()) != '\n')  //子串不存
			if((p = nex[p][c-'a']) == 0) f = 1;//标志失败
	}
```

